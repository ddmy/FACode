window.addEventListener('load', () => {


  const ID = '##ID##'
  const IMGLIST = ##IMGLIST##
  const SPEED = ##SPEED##

  // 获取canvas的父级dom宽高
  const canvaDom = document.querySelector(ID)
  if (!canvaDom) throw new Error('canvas 未正确设置!')
  // 计算盒子实际设置的内容区域宽高, 设置canva宽高
  const style = getComputedStyle(canvaDom.parentElement, null)
  const paddingTop = parseInt(style.getPropertyValue('padding-top'))
  const paddingBottom = parseInt(style.getPropertyValue('padding-bottom'))
  const paddingLeft = parseInt(style.getPropertyValue('padding-left'))
  const paddingRight = parseInt(style.getPropertyValue('padding-right'))

  const canvaWidth = canvaDom.parentElement.clientWidth - paddingLeft - paddingRight
  const canvaHeight = canvaDom.parentElement.clientHeight - paddingTop - paddingBottom

  canvaDom.width = canvaWidth
  canvaDom.height = canvaHeight

  const maxLength = canvaWidth > canvaHeight ? canvaWidth : canvaHeight
  let ctx = null

  const setCtx = () => {
    ctx = canvaDom && canvaDom.getContext('2d')
  }

  const createImage = (arr) => {
    return new Promise((resolve, reject) => {
      const result = []
      arr.forEach((item, index) => {
        const img = new Image()
        img.src = item
        img.onload = () => {
          result[index] = img
          if (result.filter(item => item).length === arr.length) {
            resolve(result)
          }
        }
        img.onerror = err => {
          reject(err)
        }
      })
    })
  }

  const clearCanvas = () => {
    if (!ctx) {
      setCtx()
    }
    if (ctx) {
      ctx.clearRect(0, 0, canvaDom.width, canvaDom.height)
    }
  }

  const computedLength = (width, height) => {
    if (width === height) {
      return [maxLength, maxLength]
    }
    let max = 'width'
    if (height > width) {
      max = 'height'
    }
    let result = [maxLength]
    if (max === 'width') {
      result[1] = maxLength / (width / height)
    } else if (max === 'height') {
      result[1] = maxLength * (width / height)
    }
    return result
  }

  const setDrawImage = (img) => {
    clearCanvas()
    if (!ctx) {
      setCtx()
    }
    if (ctx) {
      ctx.drawImage(img, 0, 0, ...computedLength(img.width, img.height))
    }
  }

  createImage(IMGLIST).then(res => {
    let drawIndex = 0
    setInterval(() => {
      setDrawImage(res[drawIndex])
      drawIndex++
      if (drawIndex === res.length) {
        drawIndex = 0
      }
    }, SPEED)
  }).catch(err => {
    console.error(err)
  })
  
})